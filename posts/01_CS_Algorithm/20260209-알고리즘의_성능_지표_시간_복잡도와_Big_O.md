---
title: "알고리즘의 성능 지표: 시간 복잡도와 Big O (feat. 본체에서 이륙 소리가 나요)"
description: "코드가 왜 이렇게 느리냐고요? 그래프와 코드로 보는 시간 복잡도의 세계! 여러분의 코드를 람보르기니로 만들어봅시다."
date: 2026-02-09
update: 2026-02-09
tags: [CS, 알고리즘, 시간복잡도, BigO, 개그, 개발자]
---

# 알고리즘의 성능 지표: 시간 복잡도와 Big O (feat. 본체에서 이륙 소리가 나요)

## 서론
"어라? 왜 멈췄지...?" 

분명 로직은 완벽했습니다. 코드 한 줄 한 줄 정성을 다해 짰거든요. 그런데 테스트 데이터 10만 개를 넣고 실행 버튼을 누르는 순간, 제 책상 밑에 있던 본체가 갑자기 **"우우우웅-!!"** 하며 비행기 이륙하는 소리를 내기 시작했습니다. 

![비행기 이륙하는 본체 짤](/images/01_CS_Algorithm/time_complexity/takeoff_pc.png)
*(여기에 '제트기 엔진 소리가 나는 본체'나 '열을 뿜는 컴퓨터' 짤을 넣어주세요!)*

모니터 속 커서는 뱅글뱅글 돌기만 하고, 작업 관리자를 켜보니 CPU 점유율은 이미 100%를 찍고 있더라고요. 이게 바로 말로만 듣던 **'시간 복잡도의 저주'**였습니다. 오늘은 저처럼 컴퓨터를 난로로 만들지 않기 위해 우리가 꼭 알아야 할 **시간 복잡도와 Big O**에 대해 유쾌하면서도 '빡세게' 알아보겠습니다!

## 본론

### 1. 시간 복잡도? 그냥 '컴퓨터의 고생 지수'입니다!
시간 복잡도는 단순히 '몇 초 걸리냐'가 아니라, **'데이터($n$)가 늘어날 때 컴퓨터가 몇 번이나 더 개고생을 해야 하느냐'**를 나타내는 척도입니다. 실제 물리적 시간은 컴퓨터 사양에 따라 다르지만, **연산 횟수**는 변하지 않는 절대적인 기준이거든요. 

### 2. 한눈에 보는 Big O 그래프
백 마디 말보다 한 장의 그림이 낫겠죠? 아래 그래프는 데이터 양($n$)에 따라 연산 횟수가 어떻게 증가하는지 보여줍니다.

![Big O Complexity Chart](/images/01_CS_Algorithm/time_complexity/big_o_graph.png)
*(여기에 표준 Big O 그래프를 넣어주세요. O(n^2)이 하늘로 치솟는 그 그래프 맞습니다!)*

---

### 3. 코드로 보는 빅오 (누가 더 빠를까?)

이론만 보면 재미없으니, 실제 코드로 비교해 봅시다. "배열 안에 특정 숫자(Target)가 있는지 찾아라!"라는 문제를 두 가지 방법으로 풀어볼게요.

#### ⚡ Case A: 성실함의 정석 (O(n))
배열을 처음부터 끝까지 하나씩 확인하는 방법입니다. 데이터가 100개면 최대 100번만 확인하면 되죠.

```java
public boolean linearSearch(int[] arr, int target) {
    for (int num : arr) {
        if (num == target) return true; // 찾았다 내 사랑!
    }
    return false;
}
```
> **컴퓨터의 평:** "음, 꽤 할만하군. 데이터가 늘어나는 만큼만 더 일하면 되겠어."

#### 🔥 Case B: "생각 없이 짠" 중복 확인 (O(n²))
문제를 살짝 바꿔서 "배열 안에 중복된 숫자가 있는지 확인해라!"라고 했을 때, 무심코 이중 반복문을 돌리면 벌어지는 일입니다.

```java
public boolean hasDuplicate(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
        for (int j = 0; j < arr.length; j++) {
            if (i != j && arr[i] == arr[j]) return true;
        }
    }
    return false;
}
```
> **컴퓨터의 평:** "잠깐만... 데이터가 10만 개인데 이걸 100억 번이나 하라고? 나 퇴사할래!" (본체 이륙 소리의 주범)

---

### 4. 숫자로 보는 팩트 폭격 (n=100,000일 때)
데이터가 10만 개일 때 각 복잡도별 연산 횟수를 표로 비교해 봅시다.

| 복잡도 | 연산 횟수 (대략) | 체감 속도 | 본체 상태 |
| :--- | :--- | :--- | :--- |
| **O(log n)** | 약 17번 | 빛의 속도 | 평온 |
| **O(n)** | 100,000번 | 눈 깜빡할 사이 | 고요 |
| **O(n log n)** | 약 1,700,000번 | 매우 쾌적 | 미풍 |
| **O(n²)** | **10,000,000,000번** | **한 세월...** | **폭풍 전야 (팬 풀가동)** |

### 5. 실전 꿀팁: 내 코드를 람보르기니로 만드는 법
1. **반복문의 중첩을 최소화하세요:** `for`문 안에 `for`문이 보인다면 일단 "이거 위험한데?"라고 의심해봐야 합니다.
2. **자료구조를 활용하세요:** 위에서 본 중복 확인(O(n²))도 `HashSet` 같은 자료구조를 쓰면 $O(n)$으로 줄일 수 있습니다. (이건 다음 포스팅에서 다룰게요!)
3. **이미 정렬되어 있다면?** `O(n)` 대신 **이진 탐색($O(log n)$)**을 사용해서 컴퓨터에게 휴가를 주도록 합시다.

## 결론 및 요약 / 회고
오늘은 우리 소중한 본체의 수명을 연장해줄 시간 복잡도에 대해 알아봤습니다. 
1. **Big O 그래프**에서 내 코드가 '데드존'($O(n^2)$ 이상)에 있지 않은지 확인하자.
2. 가급적 **$O(n log n)$** 이하의 효율적인 알고리즘을 지향하자.

처음엔 수학 같아서 머리 아플 수 있지만, "내 코드가 데이터를 만났을 때 얼마나 힘들어할까?"를 상상해보는 것만으로도 여러분은 이미 훌륭한 개발자의 길을 걷고 계신 겁니다. 우리 모두 본체를 아끼는, 간지 나는 개발자가 됩시다!

## 참고 자료
- [Big-O Cheat Sheet](https://www.bigocheatsheet.com/) - 포스팅에 사용된 그래프의 원천입니다.
- Hello Coding 그림으로 개념을 잡는 알고리즘 - 진짜 그림 많고 재밌습니다. 강력 추천!
- 내 본체의 쿨러 소리 - 실시간으로 복잡도를 알려주는 가장 솔직한 물리적 지표입니다.
