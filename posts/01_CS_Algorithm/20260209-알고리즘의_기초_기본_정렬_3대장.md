---
title: "알고리즘의 기초: 기본 정렬 3대장 (버블, 선택, 삽입) 완벽 이해"
description: "느리지만 착한 친구들? 아니, 그냥 느린 친구들입니다. 기본 정렬의 원리와 '왜 쓰면 안 되는지'를 유쾌하게 알아봅시다!"
date: 2026-02-09
update: 2026-02-09
tags: [CS, 알고리즘, 자료구조, 정렬, Sorting, 버블정렬, 선택정렬, 삽입정렬]
---

# 알고리즘의 기초: 기본 정렬 3대장 (버블, 선택, 삽입) 완벽 이해

## 서론
안녕하세요! 지난번 스택과 큐로 데이터를 예쁘게 정리하는 법을 배웠다면, 오늘은 뒤죽박죽 섞여 있는 데이터를 순서대로 나열하는 **'정렬(Sorting)'**에 대해 이야기해 보려 합니다.

정렬 알고리즘은 정말 많지만, 오늘은 가장 기초가 되는 **버블(Bubble), 선택(Selection), 삽입(Insertion)** 정렬을 다룹니다. 미리 스포일러를 하자면, 이 친구들은 모두 지난번에 배웠던 **'지옥에서 온 중첩문(O(n²))'**의 주인공들입니다. 하지만 기초를 알아야 나중에 배울 '퀵'이나 '병합' 정렬이 얼마나 대단한지 알 수 있거든요!

![답답한 정렬 짤](/images/01_CS_Algorithm/basic_sorting/slow_sort_meme.png)
*(여기에 '아주 천천히 움직이는 나무늘보'나 '답답해하는 개발자' 짤을 넣어주세요!)*

## 본론

### 1. 버블 정렬 (Bubble Sort): "옆 놈이랑 계속 싸우기"
버블 정렬은 이름처럼 거품이 보글보글 올라오는 것과 비슷합니다. 인접한 두 데이터를 비교해서 큰 놈을 계속 뒤로 보내는 방식이죠.

- **성격:** 제일 단순하지만 제일 비효율적입니다. (알고리즘계의 거북이)
- **특징:** 한 번 훑고 나면 제일 큰 놈이 맨 뒤로 '보글보글' 올라와 있습니다.

```java
public void bubbleSort(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
        for (int j = 0; j < arr.length - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp; // 자리를 바꾼다 (Swap)
            }
        }
    }
}
```
> **컴퓨터의 평:** "계속 옆 사람한테 물어보느라 목이 다 쉬었어... 너무 비효율적이야!"

---

### 2. 선택 정렬 (Selection Sort): "제일 작은 놈만 패기"
전체 데이터 중에서 제일 작은 놈을 '선택'해서 맨 앞으로 보내는 방식입니다. 그다음엔 나머지 중에서 또 제일 작은 놈을 골라 두 번째로 보내죠.

- **성격:** 눈썰미는 좋지만 행동은 느립니다.
- **특징:** 데이터 상태가 어떻든 무조건 끝까지 다 훑어야 해서 기복 없이 항상 느립니다.

```java
public void selectionSort(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[minIndex]) minIndex = j; // 제일 작은 놈 찾기
        }
        int temp = arr[minIndex];
        arr[minIndex] = arr[i];
        arr[i] = temp; // 발견한 제일 작은 놈을 현재 위치로!
    }
}
```
> **컴퓨터의 평:** "처음부터 끝까지 다 쳐다보느라 눈알 빠지는 줄 알았어."

---

### 3. 삽입 정렬 (Insertion Sort): "카드를 정리하듯"
우리가 손에 든 카드를 순서대로 꽂아 넣는 것과 비슷합니다. 두 번째 데이터부터 시작해서, 자기보다 앞에 있는 놈들과 비교하며 적절한 위치에 '삽입'하는 방식입니다.

- **성격:** 기초 3대장 중에서는 제일 똑똑합니다. 
- **특징:** 데이터가 이미 거의 정렬되어 있다면 $O(n)$에 가까운 미친 속도를 보여주기도 합니다.

```java
public void insertionSort(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j]; // 나보다 큰 놈들은 한 칸씩 밀려나!
            j--;
        }
        arr[j + 1] = key; // 빈자리에 쏙!
    }
}
```
> **컴퓨터의 평:** "오, 이미 정렬된 건 금방 끝나네? 역시 난 스마트해."

---

### 4. 한눈에 보는 기초 정렬 비교

| 알고리즘 | 시간 복잡도 (최악) | 시간 복잡도 (최선) | 장점 | 단점 |
| :--- | :--- | :--- | :--- | :--- |
| **버블 정렬** | $O(n^2)$ | $O(n^2)$ | 구현이 매우 쉽다 | **제일 느리다** (말 그대로 보글보글) |
| **선택 정렬** | $O(n^2)$ | $O(n^2)$ | 교환 횟수가 적다 | 데이터 상태가 좋아도 무조건 다 본다 |
| **삽입 정렬** | $O(n^2)$ | **$O(n)$** | **거의 정렬된 상태에선 최강** | 데이터가 많아질수록 지옥을 본다 |

![정렬 비교 그래프](/images/01_CS_Algorithm/basic_sorting/sorting_comparison_graph.png)
*(여기에 각 정렬의 성능 차이를 보여주는 그래프나 애니메이션 링크 짤을 넣어주세요!)*

## 결론 및 요약 / 회고
오늘은 정렬의 가장 기본이 되는 3인방을 만나봤습니다. 
사실 이 친구들은 데이터가 조금만 많아져도 본체에서 이륙 소리를 내게 만드는 주범들입니다. 하지만 **삽입 정렬**처럼 상황에 따라 압도적인 성능을 내는 경우도 있으니, "무조건 느리다"고 무시해서는 안 되겠죠?

앞으로는 코드를 짜다가 "이 데이터를 정렬해야 하는데..." 싶을 때, 무작정 이중 루프를 돌리기 전에 오늘 배운 친구들을 떠올려보세요. 그리고 다음 포스팅에서 배울 **퀵 정렬(Quick Sort)**을 기다리며 "더 빠른 길은 없을까?" 고민해 보시길 바랍니다!

오늘도 즐겁게 코딩하시고, 우리 소중한 컴퓨터에게 휴식을 줍시다! 

## 참고 자료
- [Visualgo - Sorting](https://visualgo.net/en/sorting) - 버블, 선택, 삽입 정렬이 움직이는 걸 직접 보세요!
- Hello Coding 그림으로 개념을 잡는 알고리즘
- [Sorting Algorithms Animations](https://www.toptal.com/developers/sorting-algorithms) - 다양한 데이터 상태에 따른 정렬 속도 비교 사이트입니다.
