---
title: "Java 멀티 스레드와 동시성(Concurrency) 프로그래밍: 핵심 개념과 안전한 설계"
series_order: 4
description: "혼자 일하면 빠르지만, 함께 일하면 복잡해집니다. 자바 멀티 스레딩의 핵심 개념과 안전하게 동시성을 다루는 법을 알아봅니다."
date: 2026-02-10
update: 2026-02-10
tags: [Java, MultiThread, Concurrency, 동시성, 병렬성, 백엔드, 스레드풀]
---

# Java 멀티 스레드와 동시성(Concurrency) 프로그래밍: 핵심 개념과 안전한 설계

## 서론
여러분의 컴퓨터 작업 관리자를 열어보세요. CPU 그래프가 요동치며 수백 개의 프로세스가 돌아가고 있을 겁니다. 우리 자바 애플리케이션도 마찬가지입니다. 사용자가 동시에 수천 명씩 몰려드는데, 요리사가 단 한 명뿐인 주방처럼 한 번에 한 주문만 처리한다면 그 서비스는 응답 지연 문제를 피할 수 없을 것입니다.

![멀티 스레드 모델 개념도](/images/02_Back-end/Java_Multi_Threading_and_Concurrency/multi_thread_model.png)
*하나의 프로세스 내에서 여러 개의 스레드가 자원을 공유하며 병렬적으로 업무를 수행하는 멀티 스레딩 아키텍처입니다.*

하지만 요리사를 무작정 늘린다고 해결될까요? 좁은 주방에서 요리사 10명이 서로 프라이팬을 잡으려 싸운다면 오히려 요리 속도는 더 느려질 겁니다. 오늘은 자바가 이 **동시성(Concurrency)**이라는 까다로운 문제를 어떻게 다루는지, 그리고 우리가 왜 스레드를 직접 건드리면 안 되는지 파헤쳐 보겠습니다.

## 본론

### 1. 프로세스 vs 스레드: 가게와 요리사의 관계
멀티 태스킹을 이해하려면 먼저 프로세스와 스레드의 차이를 알아야 합니다.

- **프로세스(Process)**: 실행 중인 프로그램 그 자체입니다. 독립된 메모리 공간을 가진 '가게'와 같습니다.
- **스레드(Thread)**: 프로세스 안에서 실질적으로 일을 하는 '요리사'입니다. 가게 안의 주방 시설(메모리)을 공유하며 일합니다.

| 구분 | 프로세스 (Process) | 스레드 (Thread) |
| :--- | :--- | :--- |
| **메모리** | 독립적 (서로 간섭 불가) | 공유 (같은 데이터 접근 가능) |
| **비용** | 생성 시 자원을 많이 먹음 | 상대적으로 가볍고 빠름 |
| **통신** | 복잡함 (IPC 등 필요) | 매우 쉬움 (하지만 위험함) |

---

### 2. 동시성(Concurrency) vs 병렬성(Parallelism)
많은 분이 헷갈려 하는 개념입니다. 간단하게 정의해 보죠.

- **동시성**: 혼자서 프라이팬 4개를 번갈아 가며 요리하는 것 (싱글 코어에서 여러 일을 하는 것처럼 보이게 함)
- **병렬성**: 요리사 4명이 각자 프라이팬 하나씩 잡고 동시에 요리하는 것 (멀티 코어에서 실제로 동시에 처리함)

![동시성 vs 병렬성 개념 도식](/images/02_Back-end/Java_Multi_Threading_and_Concurrency/concurrency_vs_parallelism_diagram.png)
*싱글 코어에서 여러 작업을 교차 실행하는 '동시성'과 멀티 코어에서 실제로 작업을 동시에 수행하는 '병렬성'의 차이입니다.*

---

### 3. 공유 주방의 비극: Race Condition
스레드의 가장 큰 장점인 **메모리 공유**는 동시에 가장 큰 재앙입니다. 두 요리사가 동시에 같은 소금통을 잡고 들이부으면 요리는 짜게 변하겠죠. 이를 **경쟁 상태(Race Condition)**라고 합니다.

```java
// 나쁜 예시: 스레드 안전하지 않은 카운터
class Counter {
    private int count = 0;
    void increment() { count++; } // 여기서 사고가 납니다!
}
```

`count++`는 보기엔 한 줄이지만, 실제로는 (1. 읽고, 2. 더하고, 3. 저장하는) 3단계 작업입니다. 두 스레드가 1단계를 동시에 하면 결과적으로 숫자가 하나만 올라가는 마법(?)을 보게 됩니다.

> **컴퓨터의 평**: "주인님, 데이터가 자꾸 엉뚱하게 바뀌어요! 제발 문 좀 잠가주세요(Lock)!"

---

### 4. 실무력을 높이는 결정적 인사이트
멀티 스레드 프로그래밍을 할 때 반드시 지켜야 할 두 가지 철칙이 있습니다.

#### ① 스레드를 직접 `new` 하지 마세요
요리사가 필요할 때마다 길거리에서 새로 고용하고, 요리가 끝나면 해고하는 건 엄청난 낭비입니다. 대신 요리사들을 미리 대기시켜 두는 **스레드 풀(Thread Pool)**을 사용하세요. 자바에서는 `ExecutorService`가 이 역할을 훌륭하게 수행합니다.

#### ② 가능한 한 불변(Immutable) 상태를 유지하세요
공유하는 데이터가 아예 변하지 않는다면(final), 요리사들이 싸울 일도 없습니다. 실무에서 `String`이나 `Optional` 같은 불변 객체들이 사랑받는 이유 중 하나가 바로 멀티 스레드 환경에서 매우 안전하기 때문입니다.

```java
// 좋은 예시: ExecutorService 활용
ExecutorService executor = Executors.newFixedThreadPool(10);
executor.submit(() -> {
    // 안전하게 처리할 로직
});
```

## 결론 및 요약 / 회고
멀티 스레드는 자바 백엔드 성능의 핵심이지만, 동시에 가장 많은 버그를 양산하는 지뢰밭이기도 합니다.
1. **프로세스**는 가게, **스레드**는 요리사입니다.
2. **동시성**은 속도보다 **효율**의 문제입니다.
3. 데이터 오염을 막으려면 **동기화(Synchronization)**나 **불변성**을 확보해야 합니다.

오늘 공부를 통해 제 코드 속에서 요리사들이 서로 싸우고 있지는 않았는지 반성하게 되었습니다. 단순히 "빠르게" 처리하는 것보다 "정확하게" 처리하는 동시성 설계자가 되기 위해 더 노력해야겠습니다.

오늘도 여러분의 애플리케이션이 데드락 없이 평온하게 돌아가길 응원합니다!

## 참고 자료
- Java Concurrency in Practice (브라이언 게츠 저)
- [Baeldung - Java Concurrency](https://www.baeldung.com/java-concurrency)
- 자바 성능 튜닝 이야기 (이상민 저)
---
