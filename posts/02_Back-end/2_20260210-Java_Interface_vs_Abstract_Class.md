---
title: "Java 객체지향 설계: 인터페이스와 추상 클래스의 차이 및 실무 적용"
series_order: 2
description: "상속은 알겠는데 인터페이스는 왜 쓰는 걸까요? 실무에서 코드를 살리는 유연한 설계의 비밀을 파헤쳐 봅니다."
date: 2026-02-10
update: 2026-02-10
tags: [Java, 객체지향, OOP, 인터페이스, 추상클래스, 백엔드설계]
---

# Java 객체지향 설계: 인터페이스와 추상 클래스의 차이 및 실무 적용

## 서론
객체지향 프로그래밍(OOP)을 공부할 때 우리는 흔히 '붕어빵 틀' 비유를 만납니다. 하지만 실무에서 우리가 만드는 건 붕어빵이 아니라, 수만 개의 부품이 얽히고설킨 거대한 기계에 가깝습니다. 

부품 하나를 바꿨는데 기계 전체가 멈춰버린다면? 혹은 새로운 기능을 추가하려는데 기존 코드를 다 갈아엎어야 한다면? 이런 비극을 막기 위해 우리는 **추상 클래스**와 **인터페이스**라는 설계 도면을 사용합니다. 오늘은 이 두 녀석이 대체 뭐가 다르고, 언제 써야 적절한지 알아보겠습니다.

![객체지향 설계의 추상화 계층](/images/02_Back-end/Java_Interface_vs_Abstract_Class/oop_abstraction_layers.png)
*구체적인 구현체에 의존하지 않고 추상화된 계층에 의존하여 설계의 유연성을 확보하는 개념도입니다.*

## 본론

### 1. 추상 클래스 (Abstract Class): "나는 너의 뿌리다"
추상 클래스는 '미완성 설계도'입니다. 자식 클래스들이 공통으로 가져야 할 성질(필드)과 기능(메서드)을 물려주는 것이 주 목적이죠. 

- **핵심 키워드:** **상속(Is-A)**, **확장**.
- **인사이트:** "너는 내 자식이니까 이 기능은 기본으로 가지고 있고, 부족한 건 네가 직접 구현해라"라는 느낌입니다. 부모와 자식 간의 강력한 유대 관계를 전제로 합니다.

```java
abstract class Hero {
    String name;
    void move() { System.out.println("걸어서 이동!"); } // 공통 기능
    abstract void attack(); // 자식이 반드시 구현해야 할 특수 기능
}
```

### 2. 인터페이스 (Interface): "너랑 나랑은 계약 관계야"
인터페이스는 '기능 명세서' 또는 '계약서'입니다. 어떤 클래스가 이 인터페이스를 구현한다면, "나는 이 기능을 반드시 제공하겠다"라고 약속하는 것과 같습니다.

- **핵심 키워드:** **구현(Can-Do)**, **다형성**.
- **인사이트:** 혈연관계(상속)는 아니지만, "하늘을 날 수 있는 기능이 필요해? 그럼 이 계약서에 사인(implements)해!"라는 식입니다. 전혀 다른 종류의 클래스들이 같은 기능을 공유하게 해줍니다.

```java
interface Flyable {
    void fly(); // "날고 싶으면 이 메서드를 구현해!"
}
```

---

### 3. 한눈에 비교하는 설계 도면

![추상 클래스 vs 인터페이스 구조적 차이](/images/02_Back-end/Java_Interface_vs_Abstract_Class/abstract_vs_interface_diagram.png)
*상속을 통한 확장(Is-A)과 계약을 통한 기능 구현(Can-Do)의 차이를 보여주는 구조적 비교도입니다.*

| 구분 | 추상 클래스 (Abstract Class) | 인터페이스 (Interface) |
| :--- | :--- | :--- |
| **존재 목적** | 공통된 특징을 상속받아 확장하기 위함 | 특정 기능을 구현하도록 강제하기 위함 |
| **관계 성격** | Is-A (~은 ~이다) | Can-Do (~을 할 수 있다) |
| **다중 상속** | 불가능 (단일 상속만 가능) | **가능 (여러 개 구현 가능)** |
| **변수(필드)** | 일반 변수 가질 수 있음 | 상수(static final)만 가능 |

---

### 4. 실무력을 높이는 결정적 인사이트

이 두 가지를 구분하는 가장 큰 기준은 **유연함**입니다. 왜 실무에서는 인터페이스를 더 사랑할까요?

#### ① 다중 상속의 마법
자바는 부모를 한 명만 가질 수 있습니다. 하지만 인터페이스는 무제한으로 구현할 수 있죠. 
예를 들어, `아이언맨` 클래스는 `영웅`이라는 부모(추상 클래스)를 상속받으면서도, `하늘을 나는 기능`, `미사일을 쏘는 기능`(인터페이스)을 동시에 장착할 수 있습니다. 상속만 고집했다면 결코 만들 수 없는 조합입니다.

#### ② 결합도(Coupling) 낮추기
이것이 가장 중요한 포인트입니다. 구체적인 클래스에 의존하지 않고 인터페이스에 의존하면, 나중에 기능을 교체하기가 너무 쉬워집니다. 
"나는 '칼'이 필요해"라고 하는 대신 **나는 공격할 수 있는 것(Attackable)이 필요해**라고 정의해두면, 나중에 칼을 총으로 바꿔도 호출하는 쪽의 코드는 단 한 줄도 고칠 필요가 없기 때문입니다.

```java
// 나쁜 예시: 구체적인 클래스에 의존 (결합도 높음)
void hunt(Sword sword) { sword.swing(); }

// 좋은 예시: 인터페이스에 의존 (결합도 낮음)
void hunt(Weapon weapon) { weapon.use(); } // Weapon이 칼이든 총이든 상관없음!
```
> **컴퓨터의 평:** "휴, 부품 갈아끼우기가 이렇게 편하다니! 역시 인터페이스가 최고야."

## 결론 및 요약 / 회고
추상 클래스와 인터페이스는 단순히 문법적 차이를 넘어, **변화에 얼마나 유연하게 대처할 것인가**에 대한 해답입니다.
1. **공통의 유전자**를 물려주고 싶다면 **추상 클래스**.
2. **공통의 능력**을 부여하고 결합도를 낮추고 싶다면 **인터페이스**.

처음 설계할 때는 귀찮을 수 있지만, 6개월 뒤 코드를 수정해야 할 미래의 나(혹은 동료)를 생각한다면 인터페이스를 적극 활용하는 습관을 들여야겠습니다. 붕어빵 틀을 넘어, 레고처럼 조립 가능한 우아한 코드를 짜는 그날까지 우리 모두 화이팅입니다!

## 참고 자료
- Effective Java 3rd Edition (조슈아 블로크 저)
- [Oracle Java Documentation - Interfaces](https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html)
- 객체지향의 사실과 오해 (조영호 저)
---
