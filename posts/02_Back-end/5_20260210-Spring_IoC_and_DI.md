---
title: "Spring Framework의 핵심 원리: IoC와 DI(의존성 주입) 개념 정리"
series_order: 5
description: "스프링 프레임워크의 심장인 IoC와 DI를 아주 쉽고 유쾌하게 파헤쳐 봅니다. 왜 우리는 직접 'new'를 하면 안 되는 걸까요?"
date: 2026-02-10
update: 2026-02-10
tags: [Spring, SpringBoot, IoC, DI, 백엔드, 프레임워크, 객체지향]
---

# Spring Framework의 핵심 원리: IoC와 DI(의존성 주입) 개념 정리

## 서론
자바를 공부하고 처음 스프링의 세계에 발을 들이면 가장 먼저 마주치는 거대한 장벽이 있습니다. 바로 **IoC(Inversion of Control)**와 **DI(Dependency Injection)**라는 녀석들이죠. 이름부터가 무슨 암호 같아서 우리를 당황하게 만듭니다.

![Spring IoC 컨테이너 개요](/images/02_Back-end/Spring_IoC_and_DI/ioc_container_overview.png)
*객체의 생성부터 생명주기 관리까지 개발자 대신 수행하는 스프링 IoC 컨테이너의 역할과 개념도입니다.*

분명 자바 공부할 때는 내가 필요할 때 `new` 키워드로 객체를 만들어서 잘 써왔는데, 스프링은 자꾸 "너는 가만히 있어, 내가 다 알아서 해줄게"라고 말합니다. 오늘은 스프링이 왜 내 객체의 주도권을 빼앗아 가려 하는지, 그리고 그 대가로 우리에게 어떤 편안함을 주는지 알아보겠습니다.

## 본론

### 1. 제어의 역전(IoC): 가내수공업에서 오마카세로
전통적인 프로그래밍 방식에서 객체의 생명주기(언제 만들고, 언제 쓰고, 언제 버릴지)는 전적으로 개발자의 손에 달려 있었습니다. 이것이 **제어의 순전**입니다.

하지만 스프링은 이를 뒤집습니다. 프로그램의 흐름을 내가 결정하는 게 아니라, 스프링 컨테이너라는 거대한 시스템이 결정하게 하죠. 이것이 바로 **제어의 역전(IoC)**입니다.

- **전통 방식**: 내가 먹고 싶은 요리의 재료를 직접 사고, 손질하고, 요리까지 다 함.
- **IoC 방식**: 나는 식탁에 앉아만 있음. 셰프(스프링)가 제철 재료를 골라 요리해서 내 앞에 딱 갖다 줌.

---

### 2. 의존성 주입(DI): 부품을 외부에서 조립하다
IoC가 "주도권을 넘긴다"는 추상적인 개념이라면, **DI**는 그 개념을 실현하는 구체적인 방법입니다. 클래스가 스스로 필요한 객체를 만드는 게 아니라, 외부에서 만들어진 객체를 '주입'받는 방식이죠.

| 구분 | 직접 생성 (Manual) | 의존성 주입 (DI) |
| :--- | :--- | :--- |
| **객체 생성 주체** | 클래스 내부 (new) | 외부 컨테이너 (Spring) |
| **유연성** | 낮음 (부품 갈아끼우기 힘듦) | 높음 (인터페이스만 맞으면 끝) |
| **테스트 용이성** | 어려움 (가짜 객체 넣기 힘듦) | 쉬움 (Mock 객체 주입 가능) |

![IoC 컨테이너와 Bean 주입 구조도](/images/02_Back-end/Spring_IoC_and_DI/ioc_container_di_diagram.png)
*스프링 컨테이너 내부에 등록된 Bean들이 필요한 의존성 위치에 자동으로 주입(DI)되는 흐름도입니다.*

---

### 3. 왜 굳이 주입을 받아야 할까? (좋은 예시 vs 나쁜 예시)
이유는 단순합니다. **결합도(Coupling)**를 낮추기 위해서입니다.

```java
// 나쁜 예시: 강한 결합 (직접 생성)
class ChickenStore {
    private KyochonChicken chicken = new KyochonChicken(); // 교촌만 튀길 수 있음
}

// 좋은 예시: 약한 결합 (DI 활용)
class ChickenStore {
    private final Chicken chicken; // 어떤 치킨이든 가능!

    public ChickenStore(Chicken chicken) { // 외부에서 넣어줌
        this.chicken = chicken;
    }
}
```
> **컴퓨터의 평**: "주인님, 이제 가게 주인이 치킨 브랜드를 바꿔도 저는 코드 한 줄 고칠 필요가 없어요! 주입만 새로 받으면 되니까요."

---

### 4. 실무력을 높이는 결정적 인사이트
실무에서 스프링을 다룰 때 반드시 기억해야 할 포인트는 **생성자 주입(Constructor Injection)**을 사랑해야 한다는 것입니다.

1.  **불변성 확보**: 생성자 주입을 사용하면 필드를 `final`로 선언할 수 있습니다. 한 번 주입된 객체는 변하지 않음을 보장받아 멀티 스레드 환경에서 안전합니다.
2.  **누락 방지**: `new`로 객체를 생성할 때 필요한 부품이 빠졌다면 컴파일 시점에 바로 알려줍니다. "어이, 치킨 가게인데 닭(의존성)이 없잖아!"라고요.
3.  **테스트 코드의 품격**: 스프링 없이 순수 자바 코드로 단위 테스트를 짤 때, 생성자로 가짜(Mock) 객체를 슥 넣어주기만 하면 됩니다. 테스트가 아주 우아해지죠.

## 결론 및 요약 / 회고
IoC와 DI는 스프링이라는 마법사가 우리에게 선사한 가장 강력한 도구입니다. 
- **주도권**을 스프링에게 넘기면(IoC), 
- 우리는 부품 조립(DI)에만 신경 쓰면 되고, 
- 결과적으로 **유연하고 테스트하기 쉬운 코드**를 얻게 됩니다.

처음에는 이 마법이 낯설고 번거로울 수 있습니다. 하지만 한 번 이 편리함에 익숙해지면, 다시는 모든 객체를 직접 `new` 하던 가내수공업 시절로 돌아가고 싶지 않을 것입니다.

여러분의 객체들이 스프링의 관리 하에 평온하고 유연하게 숨 쉬길 응원합니다!

## 참고 자료
- Spring Framework Documentation: Core Technologies
- 토비의 스프링 3.1 (이일민 저)
- [Baeldung - Intro to Inversion of Control and Dependency Injection](https://www.baeldung.com/spring-reverese-of-control)
---
