---
title: "SQL 튜닝 실전: 실행 계획(EXPLAIN) 분석으로 병목 지점 타격하기"
series_order: 8
description: "느린 쿼리 하나가 서비스 전체의 병목이 될 수 있습니다. 실행 계획 분석을 통해 SQL의 내부 동작을 진단하고 최적화하는 실전 기법을 알아봅니다."
date: 2026-02-11
update: 2026-02-11
tags: [Database, SQL튜닝, EXPLAIN, 실행계획, 성능최적화, 백엔드, MySQL]
---

# SQL 튜닝 실전: 실행 계획(EXPLAIN) 분석으로 병목 지점 타격하기

## 서론
평화로운 오후, 갑자기 모니터링 시스템에서 경고음이 울립니다. API 응답 시간이 길어지고 DB 서버의 CPU 점유율이 요동치기 시작하죠. 범인은 대부분 인덱스를 제대로 타지 못하는 비효율적인 쿼리입니다.

분명 인덱스를 생성했는데 왜 느린 걸까요? 이때 우리가 가장 먼저 해야 할 일은 막연한 추측이 아니라 **데이터**를 확인하는 것입니다. 데이터베이스가 쿼리를 어떻게 처리하는지 보여주는 **실행 계획(Execution Plan)**을 분석하여 병목 지점을 정확히 찾아내야 합니다.

![SQL 실행 계획 분석 개념도](/images/04_Database/SQL_Performance_Tuning_Practice/execution_plan_concept.png)
*쿼리가 옵티마이저를 거쳐 최적의 경로를 찾는 과정과 실행 계획이 제공하는 핵심 정보를 시각화한 개념도입니다.*

## 본론

### 1. EXPLAIN: 옵티마이저의 내비게이션 엿보기
MySQL에서 쿼리 앞에 `EXPLAIN` 키워드만 붙이면, 옵티마이저가 데이터를 찾기 위해 세운 상세 전략을 확인할 수 있습니다. 마치 블랙박스 같던 쿼리 실행 과정을 투명하게 보여주는 설계도와 같죠. 우리가 반드시 살펴봐야 할 핵심 지표는 다음과 같습니다.

- **type (접근 방식)**: 데이터를 어떤 방식으로 조회하는가? (가장 중요한 성능 지표)
- **rows (예상 행 수)**: 쿼리 처리를 위해 옵티마이저가 스캔할 것으로 예상하는 행의 개수.
- **Extra (추가 정보)**: 인덱스만으로 처리가 가능한가(`Using index`), 혹은 별도의 정렬 작업(`Using filesort`)이 필요한가 등의 부가 정보.

**비유**: 실행 계획 분석은 옵티마이저가 선택한 **최단 경로**를 검증하는 작업입니다. 우리가 의도한 내비게이션 경로(인덱스)대로 데이터에 접근하고 있는지 확인하는 과정이죠.

---

### 2. 'type' 컬럼으로 보는 위험 신호
실행 계획의 `type`은 쿼리의 효율성을 직관적으로 보여주는 성적표입니다. 아래는 실무에서 마주치는 타입들을 성능이 좋은 순서대로 정리한 표입니다.

| Type | 등급 | 의미 | 최적화 필요성 |
| :--- | :--- | :--- | :--- |
| **const** | S | PK나 유니크 키를 사용하여 단 1건만 조회함 | 최상 (추가 튜닝 불필요) |
| **ref** | A | 일반 인덱스를 사용하여 등호(`=`) 연산으로 조회함 | 양호 |
| **range** | B | 인덱스를 사용하여 범위(`>`, `BETWEEN`) 조회함 | 적정 (스캔 범위가 너무 넓으면 성능 저하) |
| **index** | C | 인덱스 전체를 스캔함 (Full Index Scan) | 주의 (인덱스 크기가 클 경우 I/O 부하) |
| **ALL** | F | 테이블 전체를 스캔함 (Full Table Scan) | **위험 (인덱스 설계 필수 검토)** |

---

### 3. 실전 코드로 보는 튜닝 전후
성능을 저하시키는 가장 흔한 원인은 '인덱스 컬럼의 가공'입니다.

```sql
-- 나쁜 예시: 컬럼을 함수로 감싸 인덱스의 정렬 구조를 무력화함
SELECT * FROM orders 
WHERE DATE_FORMAT(created_at, '%Y-%m-%d') = '2026-02-11';

-- 좋은 예시: 컬럼 원형을 유지하여 인덱스 범위를 직접 탐색함
SELECT * FROM orders 
WHERE created_at >= '2026-02-11 00:00:00' 
  AND created_at <= '2026-02-11 23:59:59';
```
**컴퓨터의 평**: "주인님, 컬럼을 가공해버리면 제가 가진 정렬된 지도를 참고할 수 없어요. 원형을 그대로 주셔야 제가 가장 빠른 길을 찾을 수 있습니다!"

---

### 4. JOIN 튜닝의 핵심: 드라이빙 테이블 선정
여러 테이블을 조인할 때, 어떤 테이블을 먼저 읽느냐에 따라 연산량의 단위가 달라집니다.

- **드라이빙 테이블 (Driving)**: 조인 시 먼저 읽히는 기준 테이블.
- **드리븐 테이블 (Driven)**: 나중에 읽히며 드라이빙 테이블의 레코드와 매칭되는 테이블.
- **전략**: 필터링 조건에 의해 **결과 행의 수가 더 적은 테이블**을 드라이빙 테이블로 선택해야 합니다. 그래야 드리븐 테이블의 인덱스를 탐색하는 횟수를 최소화하여 전체 성능을 끌어올릴 수 있습니다.

![Nested Loop Join 동작 구조](/images/04_Database/SQL_Performance_Tuning_Practice/nested_loop_join_diagram.png)
*드라이빙 테이블의 각 레코드마다 드리븐 테이블의 인덱스를 탐색하는 NL Join의 메커니즘을 설명하는 기술 도식입니다.*

---

### 5. 실무 최적화 인사이트
1.  **Index Condition Pushdown (ICP)**: `EXPLAIN`의 Extra 컬럼에 `Using index condition`이 보인다면 엔진이 인덱스 레벨에서 최대한 필터링을 수행하고 있다는 뜻입니다. 이는 디스크 I/O를 줄여주는 매우 효율적인 상태입니다.
2.  **Using filesort의 위험성**: `ORDER BY` 시 인덱스를 활용하지 못하면 DB는 별도의 메모리 공간에서 정렬을 시도하며 CPU 사용량을 높입니다. 정렬 기준을 복합 인덱스에 포함시켜 이 과정을 생략하는 것이 좋습니다.
3.  **데이터 분포도(Selectivity)**: 인덱스가 존재하더라도 옵티마이저가 전체 스캔(`ALL`)을 선택한다면, 인덱스를 타는 비용보다 전체를 읽는 비용이 더 싸다고 판단한 것입니다. 대략 전체 데이터의 20% 이상을 읽어야 하는 조건이라면 쿼리 조건 자체를 더 구체화해야 합니다.

## 결론 및 요약 / 회고
SQL 튜닝은 단순히 인덱스를 생성하는 것을 넘어, **데이터베이스의 실행 경로**를 검증하고 설계하는 작업입니다.
- **EXPLAIN** 분석을 습관화하여 쿼리의 건강 상태를 체크하세요.
- **Type** 지표를 통해 비효율적인 스캔이 발생하고 있지는 않은지 확인하세요.
- **인덱스 컬럼 원형**을 유지하고 적절한 조인 순서를 결정하는 것만으로도 드라마틱한 성능 향상을 경험할 수 있습니다.

복잡한 쿼리를 정교하게 다듬어 시스템 전체의 응답 속도를 개선했을 때의 성취감은 백엔드 개발자만이 느낄 수 있는 즐거움입니다.

## 참고 자료
- Real MySQL 8.0 (백은빈, 이성욱 저)
- High Performance MySQL (Baron Schwartz 저)
- [MySQL Official Manual: Optimizing Queries with EXPLAIN](https://dev.mysql.com/doc/refman/8.0/en/using-explain.html)
---
