---
title: "DB 설계의 정석: ERD 모델링과 정규화(Normalization)의 원리"
series_order: 1
description: "효율적인 데이터 구조를 만드는 법, 체계적인 DB 설계와 정규화 전략의 내부 메커니즘을 상세히 파헤쳐 봅니다."
date: 2026-02-10
update: 2026-02-11
tags: [Database, DB설계, ERD, 정규화, Normalization, 데이터베이스, 백엔드]
---

# DB 설계의 정석: ERD 모델링과 정규화(Normalization)의 원리

## 서론
서비스가 커지다 보면 데이터는 걷잡을 수 없이 불어납니다. 이때 DB 설계가 부실하다면 어떤 일이 벌어질까요? 중복 데이터가 넘쳐나고, 회원 이름을 하나 바꿨는데 다른 테이블에는 반영되지 않아 데이터 정합성이 깨지는 등 심각한 유지보수 결함이 발생합니다.

![ERD 모델링 개념도](/images/04_Database/Database_Modeling_and_Normalization/erd_conceptual_diagram.png)
*비즈니스 요구사항을 엔티티와 관계 중심의 논리 구조로 시각화한 ERD 개념도입니다.*

집을 짓기 전에 설계도가 필요하듯, DB를 만들기 전에도 **ERD(Entity Relationship Diagram)**라는 설계도가 필요합니다. 그리고 그 설계도를 효율적으로 다듬는 과정이 바로 **정규화(Normalization)**죠. 오늘은 데이터의 무결성을 보장하는 DB 설계의 핵심 원리를 파헤쳐 보겠습니다.

## 본론

### 1. ERD: 비즈니스 로직의 데이터 구조화
ERD는 우리 서비스에 어떤 '존재(Entity)'가 있고, 그들이 서로 어떤 '관계(Relationship)'를 맺고 있는지 시각적으로 보여주는 지도입니다.

- **엔티티(Entity)**: 학생, 강의, 주문 등 데이터로 관리할 대상.
- **속성(Attribute)**: 이름, 가격, 학번 등 엔티티가 가진 세부 정보.
- **관계(Relationship)**: "학생이 강의를 수강한다"와 같은 연결 고리.

**인사이트**: ERD를 잘 그린다는 것은 단순히 도형을 배치하는 것이 아닙니다. 복잡한 **비즈니스 요구사항**을 누락 없이 데이터 구조로 치환하는 정교한 모델링 과정입니다.

---

### 2. 정규화(Normalization)의 내부 기제
정규화는 데이터 중복을 최소화하고 무결성을 지키기 위해 테이블을 분해하는 과정입니다. 정규화를 소홀히 하면 **이상 현상(Anomaly)**을 겪게 됩니다.

- **삽입 이상**: 새 데이터를 넣으려는데 불필요한 정보까지 함께 넣어야 하는 상황.
- **갱신 이상**: 일부만 수정되어 데이터 불일치가 발생하는 상황.
- **삭제 이상**: 특정 정보를 지웠는데 필요한 다른 정보까지 함께 사라지는 상황.

#### ① 제1정규형 (1NF): 원자성 확보
- 모든 속성은 **원자 값(Atomic Value)**을 가져야 합니다. 하나의 칸에 여러 데이터를 욱여넣지 않는 것이 기본입니다.

#### ② 제2정규형 (2NF): 부분 함수 종속 제거
- 기본키(PK)가 복합키일 때, PK의 일부에만 종속되는 속성을 분리합니다. 
- **Under the hood**: 이는 데이터의 '부분적 의존성'을 제거하여, 특정 데이터 수정 시 관련 없는 정보가 꼬이는 것을 방지합니다.

#### ③ 제3정규형 (3NF): 이행적 함수 종속 제거
- PK가 아닌 속성 간의 종속 관계를 끊습니다. (A->B, B->C 일 때 A->C 관계가 성립하는 경우)
- **실무 포인트**: 3NF까지 지키는 것이 일반적이며, 이를 통해 데이터 수정 시의 파급 효과를 최소화할 수 있습니다.

---

### 3. 정규화 vs 성능: 트래픽과 정합성의 트레이드오프
이론적으로는 정규화가 옳지만, 실무에서는 성능을 위해 **반정규화(De-normalization)**를 선택하기도 합니다.

| 구분 | 정규화 (Normalization) | 반정규화 (De-normalization) |
| :--- | :--- | :--- |
| **목표** | 데이터 정합성 및 무결성 | 조회 성능 극대화 |
| **비용** | JOIN 연산 증가로 인한 CPU 부하 | 데이터 중복 저장 및 정합성 관리 비용 |
| **판단 근거** | 쓰기(Write)가 빈번하고 정확성이 중요함 | 읽기(Read)가 압도적이고 빠른 응답이 필요함 |

---

### 4. 실무력을 높이는 모델링 습관
1.  **인공키(Surrogate Key)의 활용**: 이메일이나 사용자 ID 같은 비즈니스 데이터는 PK로 쓰지 마세요. 언제든 바뀔 수 있습니다. 변하지 않는 `Auto Increment ID`를 PK로 쓰는 것이 유지보수에 유리합니다.
2.  **데이터 타입 다이어트**: `VARCHAR(255)`를 남발하지 마세요. 실제 데이터 크기에 맞춘 세밀한 타입 설정이 인덱스 크기를 줄이고 성능을 결정합니다.
3.  **NULL에 엄격해지기**: NULL은 검색 성능을 떨어뜨리고 로직을 복잡하게 만듭니다. 가능하면 `Default` 값을 지정하거나 테이블을 더 정교하게 분할하세요.

## 결론 및 요약 / 회고
DB 설계는 서비스의 뼈대를 만드는 작업입니다. 
- **ERD**로 데이터 간의 관계를 명확히 정의하세요.
- **정규화**를 통해 이상 현상의 가능성을 원천 차단하세요.
- 성능 병목이 예상된다면 근거 있는 **반정규화**를 도입하세요.

잘 설계된 DB는 쿼리 한 줄로도 명확한 결과를 내놓습니다. 구조의 힘을 믿고 처음부터 탄탄하게 설계하는 습관을 들여야 합니다.

## 참고 자료
- 데이터베이스 개론 (이문구 저)
- [Baeldung - Database Normalization Rules](https://www.baeldung.com/cs/database-normalization)
- SQL 첫걸음 (아사이 아츠시 저)
---
