---
title: "SQL 성능의 핵심 인덱스(Index): B-Tree 구조와 성능 최적화 전략"
series_order: 2
description: "조회 속도를 획기적으로 개선하는 인덱스의 내부 동작 원리(B-Tree)와 실무적인 최적화 기법을 상세히 알아봅니다."
date: 2026-02-10
update: 2026-02-11
tags: [Database, Index, B-Tree, SQL튜닝, 데이터베이스, 성능최적화, 백엔드]
---

# SQL 성능의 핵심 인덱스(Index): B-Tree 구조와 성능 최적화 전략

## 서론
수만 권의 책이 있는 거대한 도서관에서 원하는 책을 한 권 찾아야 한다고 상상해 보세요. 만약 도서 목록(Index)이 없다면, 우리는 첫 번째 서가부터 마지막 서가까지 모든 책을 하나하나 확인해야 할 겁니다. 데이터베이스도 마찬가지입니다. 인덱스가 없는 테이블에서 데이터를 찾는 것은 **Full Table Scan**이라는 비효율적인 탐색을 의미합니다.

![도서관 인덱스 개념도](/images/04_Database/Database_Index_and_BTree/library_index_concept.png)
*방대한 데이터 속에서 원하는 정보를 빠르게 찾기 위한 인덱스의 필요성을 도서관의 도서 목록에 비유한 개념도입니다.*

오늘은 쿼리 성능의 핵심인 **인덱스(Index)**의 내부 구조인 **B-Tree**에 대해 알아보고, InnoDB 환경에서 인덱스가 어떻게 물리적으로 저장되는지 딥다이브 해보겠습니다.

## 본론

### 1. 인덱스(Index): 읽기를 위한 쓰기의 희생
인덱스는 조회 속도를 높이기 위해 별도로 관리하는 자료구조입니다. 하지만 공짜는 아닙니다. **쓰기(INSERT, UPDATE, DELETE) 성능**을 일부 포기해야 하죠.

- **장점**: 특정 데이터를 찾는 탐색 범위가 획기적으로 줄어듭니다.
- **단점**: 인덱스를 저장할 추가 공간이 필요하며, 데이터 변경 시 인덱스 페이지도 다시 정렬(Split)해야 하므로 오버헤드가 발생합니다.

---

### 2. B-Tree: 범위 검색에 최적화된 균형 트리
대부분의 관계형 DB는 인덱스 구조로 **B-Tree (Balanced Tree)**를 사용합니다. 해시 테이블이 아닌 트리를 쓰는 결정적인 이유는 무엇일까요?

- **Under the hood**: 해시 테이블은 특정 값(`=`)을 찾는 데는 $O(1)$로 빠르지만, 데이터가 정렬되어 있지 않아 범위 검색(`BETWEEN`, `>`, `<`)이 불가능합니다. 반면 B-Tree는 항상 정렬 상태를 유지하며 $O(log N)$의 일관된 성능을 보장합니다.

![B-Tree 구조도](/images/04_Database/Database_Index_and_BTree/btree_structure_diagram.png)
*Root, Branch, Leaf 노드가 균형 있게 배치되어 데이터 탐색의 효율성을 보장하는 B-Tree의 내부 논리 구조도입니다.*

- **Leaf 노드의 연결 리스트**: B-Tree의 리프 노드들은 서로 연결되어 있어, 한 번 시작점을 찾으면 다음 데이터로 넘어가는 '스캔' 작업이 매우 빠릅니다.

---

### 3. InnoDB의 특권: Clustered Index
MySQL의 InnoDB 엔진은 인덱스를 다루는 방식이 독특합니다. 바로 **클러스터형 인덱스(Clustered Index)**입니다.

- **클러스터형 인덱스 (PK)**: 실제 데이터 행 자체가 인덱스의 리프 노드에 저장됩니다. 즉, 테이블 자체가 하나의 거대한 인덱스인 셈입니다. PK 조회가 압도적으로 빠른 이유입니다.
- **세컨더리 인덱스 (보조 인덱스)**: PK 이외의 인덱스입니다. 리프 노드에 데이터 주소가 아닌 **PK 값**을 들고 있습니다. 
- **인사이트**: 따라서 세컨더리 인덱스로 검색하면 `인덱스 탐색 -> PK 획득 -> PK로 실제 데이터 탐색`이라는 두 번의 과정을 거치게 됩니다. PK 설계가 중요한 기술적 이유입니다.

---

### 4. 인덱스를 타는 쿼리 vs 못 타는 쿼리
인덱스를 만들었다고 무조건 빨라지지 않습니다. 쿼리 작성 습관이 성능을 결정합니다.

```sql
-- 나쁜 예시: 인덱스 컬럼을 연산함 (Index 못 탐)
SELECT * FROM members WHERE age * 2 > 40;

-- 좋은 예시: 비교 대상 값을 연산함 (Index 활용 가능)
SELECT * FROM members WHERE age > 20;

-- 나쁜 예시: 와일드카드가 앞부분에 옴 (Index 못 탐)
SELECT * FROM members WHERE name LIKE '%준오';

-- 좋은 예시: 앞부분이 고정됨 (Index 활용 가능)
SELECT * FROM members WHERE name LIKE '이준%';
```
**컴퓨터의 평**: "주인님, 컬럼 원형을 건드리면 제가 가진 지도(Index)와 대조할 수가 없어요. 원형을 보존해 주세요!"

---

### 5. 실무 최적화 인사이트
1.  **카디널리티(Cardinality) 우선순위**: 중복도가 낮은 컬럼(주민번호, ID 등)을 인덱스로 잡으세요. 성별처럼 중복도가 높은 컬럼은 인덱스를 타는 것보다 그냥 전체를 다 읽는 게 빠를 수도 있습니다.
2.  **가장 왼쪽의 원칙 (Leftmost Prefix)**: 복합 인덱스 `(A, B, C)`를 만들었다면, `A` 없이는 `B`나 `C`만으로 인덱스를 사용할 수 없습니다. 검색 빈도가 높은 컬럼을 가장 왼쪽에 배치하세요.
3.  **Covering Index**: 쿼리에 필요한 모든 컬럼이 인덱스 안에 다 들어있다면, 실제 데이터 페이지에 접근하지 않고 인덱스만 읽어서 결과를 낼 수 있습니다. 성능 최적화의 필살기입니다.

## 결론 및 요약 / 회고
인덱스는 성능 최적화의 시작이자 끝입니다. 
- **B-Tree**의 정렬 특성을 이해하고 범위 검색에 활용하세요.
- **클러스터형 인덱스**의 구조를 고려하여 PK를 작고 효율적으로 설계하세요.
- **실행 계획(EXPLAIN)**을 확인하여 내 쿼리가 인덱스를 제대로 타고 있는지 항상 의심하세요.

데이터가 수천만 건으로 늘어났을 때도 변함없이 빠른 속도를 유지하는 쿼리, 그것이 실력 있는 백엔드 개발자의 증거입니다.

## 참고 자료
- Real MySQL 8.0 (백은빈, 이성욱 저)
- SQL 성능 최적화 (조시 윈 저)
- [Use The Index, Luke](https://use-the-index-luke.com/)
---
